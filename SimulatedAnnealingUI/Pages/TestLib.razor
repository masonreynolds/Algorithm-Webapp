@page "/testlib"
@inject IJSRuntime JSRuntime;

@if (dist == 0) {
    <h1>Test Graph Library</h1><br/>
}
else {
    <h1>Test Graph Library - @dist kilometers - Temp: @temp</h1><br/>
}

<div class="row">
  <div class="column">
        <EditForm Model="@position" OnValidSubmit="HandleValidPos">
        <DataAnnotationsValidator />
        <ValidationSummary />
            <h5>Enter the Locations's Name: </h5>
            <InputText id="name" @bind-Value="position.name" /><br /><br />

            <h5>Enter the Locations's Latitude(South is Negative): </h5>
            <InputNumber id="latitude" @bind-Value="position.lat" /><br /><br />

            <h5>Enter the Locations's Longitude(West is Negative): </h5>
            <InputNumber id="longitude" @bind-Value="position.lon" /><br /><br />

            <button type="submit">Submit</button>
            <button type="button" @onclick="ClearPoses">Clear</button>
            <button type="button" disabled=@invalid @onclick="runSimAnnealing">Calculate Path</button>
        </EditForm><br />

        <svg id='globe'></svg>
  </div>
  <div class="column" id="c2">
      <h5>Locations entered: </h5>
      @if (poses.Count == 0) {
        <p id="locations" style="white-space: pre-wrap">None so far</p>
      } else {
          <ul>
            @foreach (var pose in poses) {
                <li key=@pose.ID>
                    @pose.name: @pose.lat, @pose.lon - 
                    <button class="btn btn-danger" @onclick="() => HandleRemovePos(pose.ID)">X</button>
                </li>
            }
          </ul>
      }
  </div>
</div>

@code {
    private List<Position> poses;
    private Position position;
    private List<Link> links;
    private bool rendered;
    private bool invalid;
    private Random rand;
    private double temp;
    private int dist;
    
    protected override async Task OnInitializedAsync()
    {
        poses = new List<Position>();
        position = new Position();
        links = new List<Link>();
        rendered = false;
        invalid = true;
        dist = 0;
        rand = new Random();
        await JSRuntime.InvokeVoidAsync("setRendered", false);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!rendered)
        {
            rendered = true;
            await DisplayGlobe();
        }
    }

    private async Task DisplayGlobe()
    {
        await JSRuntime.InvokeVoidAsync("createGlobe", poses, links);
    }

    private async Task HandleValidPos()
    {
        poses.Add(new Position(rand.Next(0, 100000), position.lat, position.lon, position.name));

        if (poses.Count > 2)
        {
            invalid = false;
            this.StateHasChanged();
        }

        await DisplayGlobe();
    }

    private async Task HandleRemovePos(int id)
    {
        poses = poses.Where(pose => pose.ID != id).ToList();
        links.Clear();

        if (poses.Count < 3)
        {
            invalid = true;
            this.StateHasChanged();
        }

        await DisplayGlobe();
    }

    private async Task ClearPoses()
    {
        poses.Clear();
        links.Clear();
        await DisplayGlobe();
    }

    private async Task runSimAnnealing()
    {
        invalid = true;
        WeightedGraph graph = new WeightedGraph(poses);
        IEnumerable<SimAnnealingGraph.annealResult> solutionSteps = SimAnnealingGraph.Run(graph, 500*poses.Count, 0.999, 0.001);
        foreach (var step in solutionSteps)
        {
            dist = (int)step.state.distance;
            links = step.state.links;
            temp = Math.Round(step.temp, 2);
            this.StateHasChanged();
            await DisplayGlobe();
            await Task.Delay(50);
        }
        invalid = false;
        this.StateHasChanged();
    }
}
