@page "/testlib"
@inject IJSRuntime JSRuntime;

@if (dist == 0) {
    <h1>Test Graph Library</h1><br/>
}
else {
    <h1>Test Graph Library - @dist kilometers - Temp: @temp</h1><br/>
}

<div class="row">
    <div class="column">
        <EditForm Model="@position" OnValidSubmit="HandleValidPos">
        <DataAnnotationsValidator />
        <ValidationSummary />
            <h5>Enter the Location's Name: </h5>
            <InputText id="name" @bind-Value="position.name" /><br /><br />

            <h5>Enter the Location's Latitude(South is Negative): </h5>
            <InputNumber id="latitude" @bind-Value="position.lat" /><br /><br />

            <h5>Enter the Location's Longitude(West is Negative): </h5>
            <InputNumber id="longitude" @bind-Value="position.lon" /><br /><br />

            <button type="submit" disabled=@running>Submit</button>
            <button type="button" disabled=@running @onclick="ClearPoses">Clear</button>
            <button type="button" disabled=@invalid @onclick="runSimAnnealing">Calculate Path</button>
        </EditForm><br />

        <svg id='globe'></svg>
    </div>
    <div class="column" id="c2">
        <h5>Step Speed: @stepSpeed</h5>
        <div class="slidecontainer">
            <input type="range" min="1" max="1000" class="slider" id="myRange" @bind="stepSpeed" @bind:event="oninput">
        </div>
        <br />
        <h5>Max Temperature: @maxTemp</h5>
        <div class="slidecontainer">
            <input type="range" min="1" max="100000" class="slider" id="myRange" @bind="maxTemp" @bind:event="oninput">
        </div>
        <br />
        <h5>Decrement per Step: @decrement</h5>
        <div class="slidecontainer">
            <input type="range" min="0.0001" max="0.9999" step="0.0001" class="slider" id="myRange" @bind="decrement" @bind:event="oninput">
        </div>
        <br />
        <h5>Threshold: @threshold</h5>
        <div class="slidecontainer">
            <input type="range" min="1" max="@maxTemp" class="slider" id="myRange" @bind="threshold" @bind:event="oninput">
        </div>
        <br />
        <button type="button" disabled=@running @onclick="switchSteps">Turn On/Off Updates</button>
        <br /><br />
        <h5>Locations entered: </h5>
        @if (positions.Count == 0) {
            <p id="locations" style="white-space: pre-wrap">None so far</p>
        } else {
            <ul>
                @foreach (var pose in positions) {
                    <li key=@position.ID>
                        <b>@pose.name</b>: @pose.lat, @pose.lon
                    </li>
                }
            </ul>
        }
  </div>
</div>

@code {
    private static List<Position> positions;
    private static bool invalid;
    private static bool running;
    private static TestLib comp;
    private Position position;
    private double decrement;
    private bool updatesOn;
    private bool rendered;
    private int stepSpeed;    
    private int threshold;
    private int maxTemp;
    private Random rand;
    private double temp;
    private int dist;
    
    protected override void OnInitialized()
    {
        positions = new List<Position>();
        position = new Position();
        rand = new Random();
        updatesOn = false;
        decrement = 0.999;
        rendered = false;
        maxTemp = 10000;
        running = false;
        invalid = true;
        stepSpeed = 5;
        threshold = 1;
        comp = this;
        dist = 0;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await DisplayGlobe();
    }

    private async Task DisplayGlobe()
    {
        if (!rendered)
        {
            rendered = true;
            await JSRuntime.InvokeVoidAsync("createGlobe");
        }
    }

    private async Task HandleValidPos()
    {
        Position pose = new Position(rand.Next(0, 100000), position.name, position.lat, position.lon);
        await JSRuntime.InvokeVoidAsync("addPosition", pose);

        positions = await JSRuntime.InvokeAsync<List<Position>>("getPoses");
        invalid = positions.Count < 3;
        this.StateHasChanged();
    }

    private async Task ClearPoses()
    {
        invalid = true;
        comp.StateHasChanged();
        await JSRuntime.InvokeVoidAsync("clearPoses");
    }

    private void switchSteps(MouseEventArgs e)
    {
        updatesOn = !updatesOn;
    }

    private async Task runSimAnnealing()
    {
        running = true;
        List<Position> poses = await JSRuntime.InvokeAsync<List<Position>>("getPoses");
        WeightedGraph graph = new WeightedGraph(poses);
        IEnumerable<SimAnnealingGraph.annealResult> solutionSteps = SimAnnealingGraph.Run(graph, maxTemp, decrement, threshold);

        if (updatesOn)
        {
            foreach (var step in solutionSteps)
            {
                await JSRuntime.InvokeVoidAsync("updateGlobe", step.state.positions, step.state.links);
                dist = (int)step.state.distance;
                temp = Math.Round(step.temp, 2);
                await Task.Delay(stepSpeed);
            }
        }
        else
        {
            SimAnnealingGraph.annealResult step = solutionSteps.Last();
            await JSRuntime.InvokeVoidAsync("updateGlobe", step.state.positions, step.state.links);
            dist = (int)step.state.distance;
            temp = Math.Round(step.temp, 2);
        }

        running = false;
        invalid = false;
    }

    [JSInvokable]
    public static void UpdatePoses(List<Position> poses)
    {
        positions = poses;
        invalid = positions.Count < 3 || running;
        comp.StateHasChanged();
    }
}
