@page "/testlib"
@inject IJSRuntime JSRuntime;

@if (dist == 0) {
    <h1>Test Graph Library</h1><br/>
}
else {
    <h1>Test Graph Library - @dist kilometers - Temp: @temp</h1><br/>
}

<div class="row">
  <div class="column">
        <EditForm Model="@position" OnValidSubmit="HandleValidPos">
        <DataAnnotationsValidator />
        <ValidationSummary />
            <h5>Enter the Location's Name: </h5>
            <InputText id="name" @bind-Value="position.name" /><br /><br />

            <h5>Enter the Location's Latitude(South is Negative): </h5>
            <InputNumber id="latitude" @bind-Value="position.lat" /><br /><br />

            <h5>Enter the Location's Longitude(West is Negative): </h5>
            <InputNumber id="longitude" @bind-Value="position.lon" /><br /><br />

            <button type="submit" disabled=@running>Submit</button>
            <button type="button" disabled=@running @onclick="ClearPoses">Clear</button>
            <button type="button" disabled=@invalid @onclick="runSimAnnealing">Calculate Path</button>
        </EditForm><br />

        <svg id='globe'></svg>
  </div>
  <div class="column" id="c2">
      <h5>Locations entered: </h5>
      
  </div>
</div>

@code {
    private static List<Position> positions;
    private static bool invalid;
    private static bool running;
    private static TestLib comp;
    private Position position;
    private bool rendered;
    private Random rand;
    private double temp;
    private int dist;
    
    protected override void OnInitialized()
    {
        positions = new List<Position>();
        position = new Position();
        rand = new Random();
        rendered = false;
        running = false;
        invalid = true;
        comp = this;
        dist = 0;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await DisplayGlobe();
    }

    private async Task DisplayGlobe()
    {
        if (!rendered)
        {
            rendered = true;
            await JSRuntime.InvokeVoidAsync("createGlobe");
        }
    }

    private async Task HandleValidPos()
    {
        Position pose = new Position(rand.Next(0, 100000), position.lat, position.lon, position.name);
        await JSRuntime.InvokeVoidAsync("addPosition", pose);

        positions = await JSRuntime.InvokeAsync<List<Position>>("getPoses");
        invalid = positions.Count < 3;
        this.StateHasChanged();
    }

    private async Task ClearPoses()
    {
        invalid = true;
        comp.StateHasChanged();
        await JSRuntime.InvokeVoidAsync("clearPoses");
    }

    private async Task runSimAnnealing()
    {
        running = true;
        List<Position> poses = await JSRuntime.InvokeAsync<List<Position>>("getPoses");
        WeightedGraph graph = new WeightedGraph(poses);
        IEnumerable<SimAnnealingGraph.annealResult> solutionSteps = SimAnnealingGraph.Run(graph, 100*poses.Count, 0.9999, 1);

        foreach (var step in solutionSteps)
        {
            await JSRuntime.InvokeVoidAsync("updateGlobe", step.state.positions, step.state.links);
            dist = (int)step.state.distance;
            temp = Math.Round(step.temp, 2);
            await Task.Delay(10);
        }

        running = false;
        invalid = false;
    }

    [JSInvokable]
    public static void UpdatePoses(List<Position> poses)
    {
        positions = poses;
        invalid = positions.Count < 3 || running;
        comp.StateHasChanged();
    }
}
